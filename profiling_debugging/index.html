<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/julia-ml-course/libs/katex/katex.min.css"> <link rel=stylesheet  href="/julia-ml-course/libs/highlight/styles/github.min.css"> <link rel=stylesheet  href="/julia-ml-course/css/franklin.css"> <link rel=stylesheet  href="/julia-ml-course/css/poole_hyde.css"> <style> html {font-size: 17px;} .franklin-content {position: relative; padding-left: 8%; padding-right: 5%; line-height: 1.35em;} @media (min-width: 940px) { .franklin-content {width: 100%; margin-left: auto; margin-right: auto;} } @media (max-width: 768px) { .franklin-content {padding-left: 6%; padding-right: 6%;} } </style> <link rel=icon  href="/julia-ml-course/assets/favicon.png"> <title>Julia programming for Machine Learning</title> <div class=sidebar > <div class="container sidebar-sticky"> <div class=sidebar-about > <h1><a href="/julia-ml-course/">JuML</a></h1> <p class=lead > Julia programming for ML<br> WiSe 23/24 @ TU Berlin.</p> </div> <div class=sidebar-nav-section >Course overview</div> <a class="sidebar-nav-item " href="/julia-ml-course/">General Information</a> <a class="sidebar-nav-item " href="/julia-ml-course/E1_Installation/">Installation</a> <a class="sidebar-nav-item " href="/julia-ml-course/E2_Help/">Getting Help</a> <div class=sidebar-nav-section >Julia basics</div> <a class="sidebar-nav-item " href="/julia-ml-course/L1_Basics_1/">Types, Functions & MD</a> <a class="sidebar-nav-item " href="/julia-ml-course/L2_Basics_2/">Arrays & Linear Algebra</a> <a class="sidebar-nav-item " href="/julia-ml-course/L4_Basics_3/">Dicts, Sets and Custom Types</a> <div class=sidebar-nav-section >Julia ecosystem</div> <a class="sidebar-nav-item " href="/julia-ml-course/L3_Plotting/">Plotting & DataFrames</a> <a class="sidebar-nav-item " href="/julia-ml-course/L5_Machine_Learning/">Machine Learning</a> <a class="sidebar-nav-item " href="/julia-ml-course/L6_Automatic_Differentiation/">Automatic Differentiation</a> <a class="sidebar-nav-item " href="/julia-ml-course/L7_Deep_Learning/">Deep Learning</a> <div class=sidebar-nav-section >Workflows</div> <a class="sidebar-nav-item " href="/julia-ml-course/workflows/">Scripts, Experiments & Packages</a> <a class="sidebar-nav-item active" href="/julia-ml-course/profiling_debugging/">Profiling & Debugging</a> <div class=sidebar-nav-section >Homework</div> <a class="sidebar-nav-item " href="/julia-ml-course/H1_Basics/">Week 1</a> <a class="sidebar-nav-item " href="/julia-ml-course/H2_Linear_Algebra/">Week 2</a> <a class="sidebar-nav-item " href="/julia-ml-course/H3_Custom_Types/">Week 3</a> <a class="sidebar-nav-item " href="/julia-ml-course/H4_Deep_Learning/">Week 4</a> </nav> <br> </div> </div> <div class="content container"> <div class=franklin-content ><h1 id=lesson_9_profiling_and_debugging ><a href="#lesson_9_profiling_and_debugging" class=header-anchor >Lesson 9: Profiling and Debugging</a></h1> <p>In this lesson, we are going to take a look at debugging and profiling. Since type inference is central to writing performant Julia code, we will also take a look at how to fix inference problems.</p> <p>We will demonstrate both the Julia VSCode extension and editor-agnostic packages.</p> <p> <h2>Table of Contents</h2> <div class=franklin-toc ><ol><li><a href="#debugging">Debugging</a><ol><li><a href="#vscode_extension">VSCode extension</a><li><a href="#debuggerjl">Debugger.jl</a><li><a href="#infiltratorjl">Infiltrator.jl</a></ol><li><a href="#logging">Logging</a><ol><li><a href="#enabling_debug_messages">Enabling <code>@debug</code> messages</a><li><a href="#saving_logs_to_a_file">Saving logs to a file</a></ol><li><a href="#profiling">Profiling </a><ol><li><a href="#vscode_extension__2">VSCode extension</a><li><a href="#profileviewjl">ProfileView.jl</a></ol><li><a href="#type_stability">Type stability</a><ol><li><a href="#code_warntype"><code>@code_warntype</code></a><li><a href="#cthulhujl">Cthulhu.jl</a></ol><li><a href="#acknowledgements">Acknowledgements</a></ol></div></p> <div class="admonition note"> <p class=admonition-title >Note</p> <p>These notes are designed to accompany a live demonstration in the <i>Julia programming for Machine Learning</i> class at TU Berlin.</p> </div> <h2 id=debugging ><a href="#debugging" class=header-anchor >Debugging</a></h2> <p>Let&#39;s assume we want to compute the sum of <a href="https://mathworld.wolfram.com/ProperDivisor.html">proper divisors</a> of some integer <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>.</p> <p>As an example, the proper divisors of 4 are the numbers 1 and 2, but not 4 itself. The sum of the proper divisors of 4 is therefore 1 &#43; 2 &#61; 3.</p> <p>Assume you want to debug the following implementation</p> <pre><code class="julia hljs"><span class=hljs-keyword >function</span> sum_of_divisors(n)
    proper_divisors = filter(x -&gt; n % x == <span class=hljs-number >0</span>, <span class=hljs-number >1</span>:n)
    <span class=hljs-keyword >return</span> sum(proper_divisors)
<span class=hljs-keyword >end</span></code></pre> <p>which currently returns the wrong result for <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">n = 4</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:0.6444em;"></span><span class=mord >4</span></span></span></span>:</p> <pre><code class="julia-repl hljs">sum_of_divisors(4) # ⚠️ should return 3, but returns 7
7</code></pre> <h3 id=vscode_extension ><a href="#vscode_extension" class=header-anchor >VSCode extension</a></h3> <p>Using the Julia VSCode extension, we can click on the left on the left-most column of an editor pane to add a <em>breakpoint</em>, which is visualized by a red circle. This can be seen under point 1 in the following screenshot:</p> <p><img src="/julia-ml-course/assets/vscode_debug.png" alt="VSCode debugging" /></p> <p>By going into the Debugging pane of the Julia VSCode extension &#40;point 2&#41;, we can click <em>Run and Debug</em> to start the debugger.</p> <p>The program will automatically pause at the first breakpoint. Using the toolbar &#40;point 3&#41; at the top of the editor, we can <em>continue</em>, <em>step over</em>, <em>step into</em> and <em>step out</em> of our code.</p> <p>On the left pane, we can see the local variables inside of the current function as well as their current values &#40;point 4&#41;. Not shown on the screenshot is additional information like the call stack of the function.</p> <p>Using the information from the variables viewer, we can see that <code>sum_of_divisors&#40;4&#41;</code> incorrectly computes the list of proper divisors <code>&#91;1, 2, 4&#93;</code> instead of the expected <code>&#91;1, 2&#93;</code>. This might help us figure out that the bug is in the range of our for-loop: inside <code>filter</code>, we should iterate over <code>1:&#40;n-1&#41;</code> instead of <code>1:n</code>.</p> <div class="admonition tip"> <p class=admonition-title >Tip</p> <p>Check out the <a href="https://www.julia-vscode.org/docs/stable/userguide/debugging/">debugging documentation</a> of the Julia VSCode extension for more information.</p> </div> <h3 id=debuggerjl ><a href="#debuggerjl" class=header-anchor >Debugger.jl</a></h3> <p>If you prefer to work with other editors, <a href="https://github.com/JuliaDebug/Debugger.jl">Debugger.jl</a> is one of several alternative debuggers in Julia.</p> <p>Using the <code>@enter</code> macro, we can enter a function call and step through it. The prompt changes to <code>1|debug&gt;</code>, indicating Debugger-mode, and we can use <a href="https://github.com/JuliaDebug/Debugger.jl#debugger-commands">Debugger.jl&#39;s custom commands</a> to move through our code. The list of commands can be also be shown by typing <code>help</code> in Debugger-mode.</p> <pre><code class="julia-repl hljs"><span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > <span class=hljs-keyword >using</span> Debugger 
</span>
<span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > <span class=hljs-meta >@enter</span> sum_of_divisors(<span class=hljs-number >4</span>)
</span>In sum_of_divisors(n) at REPL[11]:1
 1  function sum_of_divisors(n)
&gt;2      proper_divisors = filter(x -&gt; n % x == 0, 1:n)
 3      return sum(proper_divisors)
 4  end

1|debug&gt; u 3 # step (u)ntil line 3
In sum_of_divisors(n) at REPL[2]:1
 1  function sum_of_divisors(n)
 2      divisors = filter(x -&gt; n % x == 0, 1:n)
&gt;3      return sum(divisors)
 4  end

About to run: (sum)([1, 2, 4])</code></pre> <p>Once again, we find out that <code>sum_of_divisors&#40;4&#41;</code> incorrectly returned included the number 4 in the list of proper divisors.</p> <h3 id=infiltratorjl ><a href="#infiltratorjl" class=header-anchor >Infiltrator.jl</a></h3> <p><a href="https://github.com/JuliaDebug/Infiltrator.jl">Infiltrator.jl</a> is an alternative to Debugger.jl which allows you to set breakpoints in your code using the <code>@infiltrate</code> macro. Calling a function which hits a breakpoint will activate the Infiltrator REPL-mode and change the prompt to <code>infil&gt;</code>.</p> <p>Similar to Debugger.jl, Infilitrator provides its own set of commands, which can be shown by typing <code>?</code> in Infiltrator-mode. In the following example, we use the <code>@locals</code> command to print all local variables:</p> <pre><code class="julia-repl hljs"><span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > <span class=hljs-keyword >using</span> Infiltrator
</span>
<span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > <span class=hljs-keyword >function</span> sum_of_divisors(n)
           proper_divisors = filter(x -&gt; n % x == <span class=hljs-number >0</span>, <span class=hljs-number >1</span>:n)
           <span class=hljs-meta >@infiltrate</span>
           <span class=hljs-keyword >return</span> sum(proper_divisors)
       <span class=hljs-keyword >end</span>
</span>sum_of_divisors (generic function with 1 method)

<span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > sum_of_divisors(<span class=hljs-number >4</span>)
</span>Infiltrating (on thread 1) sum_of_divisors(n::Int64)
  at REPL[14]:3

infil&gt; @locals
- n::Int64 = 4
- proper_divisors::Vector{Int64} = [1, 2, 4]</code></pre> <p>Again, we find out that <code>sum_of_divisors&#40;4&#41;</code> incorrectly included the number 4 in <code>proper_divisors</code>.</p> <h2 id=logging ><a href="#logging" class=header-anchor >Logging</a></h2> <p>We&#39;ve been using the logging macro <code>@info</code> frequently in this lecture. Three other logging macros exist: <code>@warn</code>, <code>@error</code> and <code>@debug</code>. We will demonstrate the use of the <code>@debug</code> macro on the example from the previous section:</p> <pre><code class="julia hljs"><span class=hljs-comment ># Content of logging.jl</span>

<span class=hljs-keyword >function</span> sum_of_divisors(n)
    proper_divisors = filter(x -&gt; n % x == <span class=hljs-number >0</span>, <span class=hljs-number >1</span>:n)
    <span class=hljs-meta >@debug</span> <span class=hljs-string >&quot;sum_of_divisors&quot;</span> n proper_divisors
    <span class=hljs-keyword >return</span> sum(proper_divisors)
<span class=hljs-keyword >end</span>

sum_of_divisors(<span class=hljs-number >4</span>) <span class=hljs-comment ># function call</span></code></pre> <h3 id=enabling_debug_messages ><a href="#enabling_debug_messages" class=header-anchor >Enabling <code>@debug</code> messages</a></h3> <p>By default, <code>@debug</code> messages are suppressed. Running the <code>logging.jl</code> file from the command line therefore doesn&#39;t output anything:</p> <pre><code class="bash hljs">$ julia logging.jl
<span class=hljs-comment ># No output!</span></code></pre> <p>Debug logging can be enabled through the <code>JULIA_DEBUG</code> environment variable by specifying the module name, e.g. <code>Main</code>. We can either do this by setting an environment variable or by prefixing our command-line call to <code>julia</code>. </p> <pre><code class="bash hljs">$ JULIA_DEBUG=Main julia logging.jl
┌ Debug: sum_of_divisors
│   n = 4
│   proper_divisors =
│    3-element Vector{Int64}:
│     1
│     2
│     4
└ @ Main ~/logging.jl:9</code></pre> <p>This correctly logged our debug message as well as the source file and line of code on which it was called.</p> <p>Environment variables can also be set inside of your Julia source code, e.g. by adding the following line to the top of the <code>logging.jl</code> file:</p> <pre><code class="julia hljs"><span class=hljs-literal >ENV</span>[<span class=hljs-string >&quot;JULIA_DEBUG&quot;</span>] = Main</code></pre>
<h3 id=saving_logs_to_a_file ><a href="#saving_logs_to_a_file" class=header-anchor >Saving logs to a file</a></h3>
<p>Using the Logging.jl module from Julia base, we can create a  <a href="https://docs.julialang.org/en/v1/stdlib/Logging/#Logging.SimpleLogger"><code>SimpleLogger</code></a> which writes logging messages to an IO object, which can be a text file.</p>
<pre><code class="julia hljs"><span class=hljs-keyword >using</span> Logging

io = open(<span class=hljs-string >&quot;log.txt&quot;</span>, <span class=hljs-string >&quot;w+&quot;</span>) <span class=hljs-comment ># open text file for writing</span>
logger = SimpleLogger(io)  <span class=hljs-comment ># simplistic logger that writes into IO-Stream (e.g. our file)</span>

<span class=hljs-keyword >function</span> sum_of_divisors(n)
    proper_divisors = filter(x -&gt; n % x == <span class=hljs-number >0</span>, <span class=hljs-number >1</span>:n)
    <span class=hljs-meta >@debug</span> <span class=hljs-string >&quot;sum_of_divisors&quot;</span> n proper_divisors
    <span class=hljs-keyword >return</span> sum(proper_divisors)
<span class=hljs-keyword >end</span>

<span class=hljs-comment ># Call function with logger</span>
with_logger(logger) <span class=hljs-keyword >do</span>
    sum_of_divisors(<span class=hljs-number >4</span>)
<span class=hljs-keyword >end</span>

<span class=hljs-comment ># Write buffered messages to file</span>
flush(io)
close(io)</code></pre>
<p>Calling this with the <code>JULIA_DEBUG&#61;Main</code> environment variable successfully creates a <code>log.txt</code> file:</p>
<pre><code class="bash hljs">$ <span class=hljs-built_in >cat</span> log.txt
┌ Debug: sum_of_divisors
│   n = 4
│   proper_divisors =
│    3-element Vector{Int64}:
│     1
│     2
│     4
└ @ Main /Users/funks/.julia/dev/DebugTestPackage/src/logging.jl:14</code></pre>
<p>If we don&#39;t just want to log a single function call, we can also create a <code>global_logger</code>:</p>
<pre><code class="julia hljs"><span class=hljs-keyword >using</span> Logging

io = open(<span class=hljs-string >&quot;log.txt&quot;</span>, <span class=hljs-string >&quot;w+&quot;</span>) <span class=hljs-comment ># open text file for writing</span>
logger = SimpleLogger(io)  <span class=hljs-comment ># simplistic logger that writes into IO-Stream (e.g. our file)</span>
global_logger(logger)      <span class=hljs-comment ># use `logger` as global logger</span>

<span class=hljs-keyword >function</span> sum_of_divisors(n)
    proper_divisors = filter(x -&gt; n % x == <span class=hljs-number >0</span>, <span class=hljs-number >1</span>:n)
    <span class=hljs-meta >@debug</span> <span class=hljs-string >&quot;sum_of_divisors&quot;</span> n proper_divisors
    <span class=hljs-keyword >return</span> sum(proper_divisors)
<span class=hljs-keyword >end</span>

sum_of_divisors(<span class=hljs-number >4</span>) <span class=hljs-comment ># all function calls are logged</span>

<span class=hljs-comment ># Write buffered messages to file</span>
flush(io)
close(io)</code></pre>

<div class="admonition warning">
  <p class=admonition-title >Logging debug messages</p>
  <p>Logging messages from the <code>@debug</code> macro always requires
  setting the <code>JULIA_DEBUG</code> environment variable.</p>
</div>

<h2 id=profiling ><a href="#profiling" class=header-anchor >Profiling </a></h2>
<p>To demonstrate profiling, we are going to use an example from the  <a href="https://github.com/timholy/ProfileView.jl">ProfileView.jl</a> documentation:</p>
<pre><code class="julia hljs"><span class=hljs-keyword >function</span> profile_test(n)
    <span class=hljs-keyword >for</span> i = <span class=hljs-number >1</span>:n
        A = randn(<span class=hljs-number >100</span>,<span class=hljs-number >100</span>,<span class=hljs-number >20</span>)
        m = maximum(A)
        Am = mapslices(sum, A; dims=<span class=hljs-number >2</span>)
        B = A[:,:,<span class=hljs-number >5</span>]
        Bsort = mapslices(sort, B; dims=<span class=hljs-number >1</span>)
        b = rand(<span class=hljs-number >100</span>)
        C = B.*b
    <span class=hljs-keyword >end</span>
<span class=hljs-keyword >end</span></code></pre>
<p>Note that this function runs the inner computation <code>n</code>-times  to obtain a more accurate profile.</p>
<h3 id=vscode_extension__2 ><a href="#vscode_extension__2" class=header-anchor >VSCode extension</a></h3>
<p>To run the profiler from the Julia VSCode extension,  simply call your code using the <code>@profview</code> macro. It is recommended to call this twice:  once to trigger compilation and once to obtain the actual profile:</p>
<pre><code class="julia hljs"><span class=hljs-meta >@profview</span> profile_test(<span class=hljs-number >1</span>)  <span class=hljs-comment ># run once to trigger compilation (ignore this one)</span>
<span class=hljs-meta >@profview</span> profile_test(<span class=hljs-number >10</span>) <span class=hljs-comment ># measure runtime</span></code></pre>
<p><img src="/julia-ml-course/assets/vscode_profile.png" alt="VSCode profiling" /></p>
<p>After calling the macro &#40;point 1&#41;, our code is highlighted by a bar plot,  indicating how much time is spent in each line of code &#40;point 2&#41;.</p>
<p>A more detailed view on this can be found in the profiler window. After selecting the relevant thread &#40;point 3&#41;, we can inspect the flame graph  of our function call &#40;point 4&#41;.</p>
<p>Vertically, this graph visualizes the call stack of our function,  with the &quot;root&quot; function call at the top and &quot;leaves&quot; at the bottom. Hovering your mouse over a block will indicate the function name,  as well as its source file and corresponding line number.</p>
<p>The duration of each function call is visualized by the horizontal space  each block takes up in the graph. On this machine, most time was spent allocating  the large random matrix <code>A</code>.</p>
<p>The color of the blocks also contains information:</p>
<ul>
<li><p>Yellow indicates calls to the garbage collector.  If you see many of these, you might want to use <code>@views</code> instead of allocating memory.</p>

<li><p>Red indicates <em>run-time dispatch</em>: the Julia compiler can&#39;t infer which types a function is going to encounter before actually running the code. We will see how to fix these using Cthulhu.jl at the end of this lecture.</p>

</ul>
<h4 id=importance_of_type_inference ><a href="#importance_of_type_inference" class=header-anchor >Importance of type inference</a></h4>
<p>Let&#39;s take a look at a <a href="https://github.com/timholy/ProfileView.jl">second example from ProfileView.jl</a>  to highlight the importance of type inference:</p>
<pre><code class="julia hljs"><span class=hljs-keyword >function</span> profile_test_sort(n, len=<span class=hljs-number >100000</span>)
    <span class=hljs-keyword >for</span> i = <span class=hljs-number >1</span>:n
        list = []
        <span class=hljs-keyword >for</span> _ <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:len
            push!(list, rand())
        <span class=hljs-keyword >end</span>
        sort!(list)
    <span class=hljs-keyword >end</span>
<span class=hljs-keyword >end</span>

<span class=hljs-meta >@profview</span> profile_test_sort(<span class=hljs-number >1</span>)  <span class=hljs-comment ># run once to trigger compilation (ignore this one)</span>
<span class=hljs-meta >@profview</span> profile_test_sort(<span class=hljs-number >10</span>) <span class=hljs-comment ># measure runtime</span></code></pre>
<p>Since <code>list &#61; &#91;&#93;</code> is of type <code>Vector&#123;Any&#125;</code>, Julia can&#39;t infer its type. This is also visible in the profile, which looks fragmented and contains many red blocks:</p>
<p><img src="/julia-ml-course/assets/vscode_profile_stab_1.png" alt="VSCode type inference 1" /></p>
<p>As expected, the function is quite slow:</p>
<pre><code class="julia-repl hljs"><span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > <span class=hljs-meta >@time</span> profile_test_sort(<span class=hljs-number >10</span>)
</span>  0.442308 seconds (1.00 M allocations: 41.165 MiB, 1.31% gc time)</code></pre>
<p>By changing the third line to <code>list &#61; Float64&#91;&#93;</code>, the Julia compiler can infer that  it is working with a <code>Vector&#123;Float64&#125;</code> and generate more performant code. We can see in the profiler that the generated code is much simpler and type stable: </p>
<p><img src="/julia-ml-course/assets/vscode_profile_stab_2.png" alt="VSCode type inference 2" /></p>
<pre><code class="julia-repl hljs"><span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > <span class=hljs-meta >@time</span> profile_test_sort(<span class=hljs-number >10</span>)
</span>  0.034384 seconds (140 allocations: 25.986 MiB, 14.58% gc time)</code></pre>
<p>This corresponds to a 10x increase in performance&#33;</p>
<h3 id=profileviewjl ><a href="#profileviewjl" class=header-anchor >ProfileView.jl</a></h3>
<p>Instead of using VSCode, we can make use of  <a href="https://github.com/timholy/ProfileView.jl">ProfileView.jl</a> to profile our code, which uses the same <code>@profview</code> macro:</p>
<pre><code class="julia-repl hljs"><span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > <span class=hljs-keyword >using</span> ProfileView
</span>
<span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > <span class=hljs-keyword >function</span> profile_test_sort(n, len=<span class=hljs-number >100000</span>)
           <span class=hljs-keyword >for</span> i = <span class=hljs-number >1</span>:n
               list = []
               <span class=hljs-keyword >for</span> _ <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:len
                   push!(list, rand())
               <span class=hljs-keyword >end</span>
               sort!(list)
           <span class=hljs-keyword >end</span>
       <span class=hljs-keyword >end</span>
</span>profile_test_sort (generic function with 1 method)

<span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > <span class=hljs-meta >@profview</span> profile_test_sort(<span class=hljs-number >1</span>)
</span>Gtk.GtkWindowLeaf(...)

<span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > <span class=hljs-meta >@profview</span> profile_test_sort(<span class=hljs-number >10</span>)
</span>Gtk.GtkWindowLeaf(...)</code></pre>
<p>This will open a new GTK window with the profile. The only difference to VSCode is that the flame graph is flipped vertically:</p>
<p><img src="/julia-ml-course/assets/profileview_2.png" alt="ProfileView.jl output" /></p>
<h2 id=type_stability ><a href="#type_stability" class=header-anchor >Type stability</a></h2>
<p>Since we&#39;ve seen how important type inference is for performance, we are going to demonstrate two tools that help us find inference problems.</p>
<p>For this purpose, we are going to use an example from the  <a href="https://github.com/JuliaDebug/Cthulhu.jl">Cthulhu.jl</a> documentation:</p>
<pre><code class="julia hljs"><span class=hljs-keyword >function</span> foo()
    T = rand() &gt; <span class=hljs-number >0.5</span> ? <span class=hljs-built_in >Int64</span> : <span class=hljs-built_in >Float64</span>
    sum(rand(T, <span class=hljs-number >100</span>))
<span class=hljs-keyword >end</span></code></pre>
<p>This function &quot;flips a coin&quot; to determine whether <code>T</code> is the type <code>Int64</code> or <code>Float64</code>. It then samples 100 numbers of type <code>T</code> and sums them up. </p>
<h3 id=code_warntype ><a href="#code_warntype" class=header-anchor ><code>@code_warntype</code></a></h3>
<p>The output of <code>@code_warntype</code> is similar to to that of <code>@code_lowered</code>, which printed  the <em>intermediate representation</em> &#40;IR&#41; of our Julia code. However, <code>@code_warntype</code> additionally shows type information:</p>
<p><img src="/julia-ml-course/assets/code_warntype_2.png" alt="@code_warntype example" /></p>
<p>We can see type-stable statements in blue/cyan: </p>
<ul>
<li><p><code>rand&#40;&#41;</code> returns a <code>Float64</code></p>

<li><p><code>rand&#40;&#41; &gt; 0.5</code> returns a <code>Bool</code></p>

</ul>
<p>Highlighted in yellow are &quot;small concrete unions&quot;, for example:</p>
<ul>
<li><p><code>T</code>, which is a union type of two types: <code>Union&#123;Type&#123;Float64&#125;, Type&#123;Int64&#125;&#125;</code></p>

<li><p>our random array of size 100, which is a <code>Union&#123;Vector&#123;Float64&#125;, Vector&#123;Int64&#125;&#125;</code></p>

<li><p>the return value of <code>sum</code>, which is a <code>Union&#123;Float64, Int64&#125;</code></p>

</ul>
<p><a href="https://julialang.org/blog/2018/08/union-splitting/">These union types are not always a problem</a>,  as long as they don&#39;t result in a combinatorial explosion of possible types.</p>
<p>A big disadvantage of <code>@code_warntype</code> is that it only shows us inferred types for the exact function call we applied the macro to.  Type instabilities in inner functions calls are not always visible.</p>
<h3 id=cthulhujl ><a href="#cthulhujl" class=header-anchor >Cthulhu.jl</a></h3>

<div class="admonition warning">
  <p class=admonition-title >Warning</p>
  <p>This is a tool for advanced users
  and might be confusing to beginners.</p>
</div>

<p><a href="https://github.com/JuliaDebug/Cthulhu.jl">Cthulhu.jl</a> is the advanced user&#39;s version of <code>@code_warntype</code>. It allows us to recursively &quot;descend deeper&quot; into our code until we find a point at which inference failed.</p>
<p>Calling <code>@descend</code> on a function will start a command-line interface to interactively explore our code with type-annotations. Since this interface is pretty dense in information, it can look intimidating:</p>
<p><img src="/julia-ml-course/assets/cthulhu_1.png" alt="Cthulhu.jl example" /></p>
<p>At the top of the output &#40;orange box&#41;, the original source code is shown with additional annotations of inferred types, e.g. <code>Union&#123;Float64, Int64&#125;</code>. By default, source code format is used, which can be nicer than <code>@code_warntype</code>&#39;s IR.</p>
<p>The second section &#40;green box&#41; shows the interactive interface of Cthulhu.jl. The letters in <code>&#91; &#93;</code> brackets are the keys that need to be typed to toggle options. For example, pressing the <code>w</code> key will highlight union types in yellow  and code with poor type inferability in red:</p>
<p><img src="/julia-ml-course/assets/cthulhu_2.png" alt="Cthulhu.jl highlighting" /></p>
<p>The bottom-most section &#40;purple box&#41; allows us to move deeper into the code. Using the arrow keys, the cursor <code>•</code> &#40;pink box&#41; can be moved to select a specific function call. Hitting enter will recursively &quot;descend&quot; into the code. To &quot;ascend&quot;, place the cursor over <code>↩</code> and hit enter.</p>
<h2 id=acknowledgements ><a href="#acknowledgements" class=header-anchor >Acknowledgements</a></h2>
<p>The code snippet used for debugging was taken from Ole Kröger&#39;s blog-post  <a href="https://opensourc.es/blog/basics-debugging/"><em>Debugging in Julia - Two different ways</em></a>. Snippets for profiling from  <a href="https://github.com/timholy/ProfileView.jl">ProfileView.jl</a> and <a href="https://github.com/JuliaDebug/Cthulhu.jl">Cthulhu.jl</a>. Many thanks to Théo Galy-Fajou for helpful discussions.</p>
<div class=page-foot >
    
    Last modified: <a href="https://github.com/adrhill/julia-ml-course/commits/main">December 14, 2023.</a><br>
    Website, code and notebooks are under <a href="https://github.com/adrhill/julia-ml-course/blob/main/LICENSE">MIT License</a> &copy; <a href="http://adrianhill.de">Adrian Hill</a>.<br>
    Built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a>, <a href="https://github.com/fonsp/Pluto.jl">Pluto.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
</div>
</div>
    </div>  
    
        



    
    
        <script src="/julia-ml-course/libs/highlight/highlight.min.js"></script>
<script>hljs.highlightAll();hljs.configure({tabReplace: '    '});</script>